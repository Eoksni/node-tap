<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Node TAP by tapjs</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Node TAP</h1>
        <p>Test Anything Protocol tools for node</p>

        <p class="view"><a href="https://github.com/tapjs/node-tap">View the Project on GitHub <small>tapjs/node-tap</small></a></p>


        <ul>
          <li><a href="https://github.com/tapjs/node-tap/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/tapjs/node-tap/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/tapjs/node-tap">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p><a href="https://travis-ci.org/tapjs/node-tap/"><img src="https://travis-ci.org/tapjs/node-tap.svg?branch=master" alt="Build Status"></a> <a href="https://ci.appveyor.com/project/isaacs/node-tap"><img src="https://ci.appveyor.com/api/projects/status/913p1ypf21gf4leu?svg=true" alt="Build Status"></a> <a href="https://coveralls.io/github/tapjs/node-tap?branch=master"><img src="https://coveralls.io/repos/tapjs/node-tap/badge.svg?branch=master&amp;service=github" alt="Coverage Status"></a></p>

<p>Includes a command line test runner for consuming TAP-generating
test scripts, and a JavaScript framework for writing such scripts.</p>

<p>Built-in support for code coverage (including instrumenting child
processes).  Coverage is printed to the command line in a terse table
by default, but tap can also open up your web browser to a pretty
report if you add <code>--coverage-report=lcov</code> to the command.</p>

<p>Works with all exception-throwing assertion libraries (chai, should,
node's built-in <code>require('assert')</code>, or just throwing yourself) but
also has a <a href="#asserts">huge library of built-in assertions</a> that you
can use if you want to have each one reported as successes.</p>

<p>Outputs in a wide variety of formats using the
<a href="http://npm.im/tap-mocha-reporter">tap-mocha-reporter</a> module.  (That
is, you can get spec output by doing <code>-Rspec</code>.  The default output is
called 'classic', based on tap 0.x's output, but with color and timing
info.)</p>

<h2>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>USAGE</h2>

<p>Write your tests in JavaScript</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> tap <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>tap<span class="pl-pds">'</span></span>)

<span class="pl-c">// you can test stuff just using the top level object.</span>
<span class="pl-c">// no suites or subtests required.</span>

<span class="pl-smi">tap</span>.<span class="pl-en">equal</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">'</span>check if numbers still work<span class="pl-pds">'</span></span>)
<span class="pl-smi">tap</span>.<span class="pl-en">notEqual</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-s"><span class="pl-pds">'</span>1 should not equal 2<span class="pl-pds">'</span></span>)

<span class="pl-c">// also you can group things into sub-tests.</span>
<span class="pl-c">// Sub-tests will be run in sequential order always,</span>
<span class="pl-c">// so they're great for async things.</span>

<span class="pl-smi">tap</span>.<span class="pl-c1">test</span>(<span class="pl-s"><span class="pl-pds">'</span>first stuff<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">t</span>) {
  <span class="pl-smi">t</span>.<span class="pl-en">ok</span>(<span class="pl-c1">true</span>, <span class="pl-s"><span class="pl-pds">'</span>true is ok<span class="pl-pds">'</span></span>)
  <span class="pl-smi">t</span>.<span class="pl-en">similar</span>({a<span class="pl-k">:</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]}, {a<span class="pl-k">:</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]})
  <span class="pl-c">// call t.end() when you're done</span>
  <span class="pl-smi">t</span>.<span class="pl-en">end</span>()
})

<span class="pl-c">// If you have a bunch of setup stuff that MUST work or else</span>
<span class="pl-c">// the rest of the tests are not worth running, then you can</span>
<span class="pl-c">// pass `{ bail: true }` to make it bail out on failure.</span>

<span class="pl-smi">tap</span>.<span class="pl-c1">test</span>(<span class="pl-s"><span class="pl-pds">'</span>must succeed or all is lost<span class="pl-pds">'</span></span>, { bail<span class="pl-k">:</span> <span class="pl-c1">true</span> }, <span class="pl-k">function</span> (<span class="pl-smi">t</span>) {
  db <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">DataBorscht</span>()
  <span class="pl-smi">t</span>.<span class="pl-en">ok</span>(db, <span class="pl-s"><span class="pl-pds">'</span>borscht setup must succeed<span class="pl-pds">'</span></span>)
  <span class="pl-smi">t</span>.<span class="pl-en">end</span>()
})

<span class="pl-c">// You can also bail out based on specific conditions, or with a</span>
<span class="pl-c">// different error message of your choosing.</span>
<span class="pl-smi">tap</span>.<span class="pl-c1">test</span>(<span class="pl-s"><span class="pl-pds">'</span>must mostly succeed or all is lost<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">t</span>) {
  db <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">DataBorscht</span>()

  <span class="pl-smi">t</span>.<span class="pl-en">ok</span>(db, <span class="pl-s"><span class="pl-pds">'</span>borscht setup<span class="pl-pds">'</span></span>)
  <span class="pl-k">if</span> (<span class="pl-k">!</span>db) {
    <span class="pl-smi">t</span>.<span class="pl-en">bailout</span>(<span class="pl-s"><span class="pl-pds">'</span>the borscht is lost.  I cannot continue.<span class="pl-pds">'</span></span>)
    <span class="pl-k">return</span>
  }

  <span class="pl-smi">t</span>.<span class="pl-en">ok</span>(<span class="pl-smi">db</span>.<span class="pl-smi">connection</span>, <span class="pl-s"><span class="pl-pds">'</span>db must have connection<span class="pl-pds">'</span></span>)
  <span class="pl-smi">t</span>.<span class="pl-en">ok</span>(<span class="pl-smi">db</span>.<span class="pl-smi">username</span>, <span class="pl-s"><span class="pl-pds">'</span>db must have username<span class="pl-pds">'</span></span>)
  <span class="pl-smi">t</span>.<span class="pl-en">equal</span>(<span class="pl-smi">db</span>.<span class="pl-c1">color</span>, <span class="pl-s"><span class="pl-pds">'</span>red<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>borscht should be red<span class="pl-pds">'</span></span>)
  <span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-smi">t</span>.<span class="pl-en">passing</span>())
    <span class="pl-smi">t</span>.<span class="pl-en">bailout</span>(<span class="pl-s"><span class="pl-pds">'</span>something weird with the data borscht.<span class="pl-pds">'</span></span>)

  <span class="pl-smi">t</span>.<span class="pl-en">end</span>()
})

<span class="pl-c">// you can specify a 'plan' if you know how many</span>
<span class="pl-c">// tests there will be in advance. Handy when</span>
<span class="pl-c">// order is irrelevant and things happen in parallel.</span>

<span class="pl-c">// Note that the function name is used if no name is provided!</span>
<span class="pl-smi">tap</span>.<span class="pl-c1">test</span>(<span class="pl-k">function</span> <span class="pl-en">planned</span> (<span class="pl-smi">t</span>) {
  <span class="pl-smi">t</span>.<span class="pl-en">plan</span>(<span class="pl-c1">2</span>)
  <span class="pl-c1">setTimeout</span>(<span class="pl-k">function</span> () {
    <span class="pl-smi">t</span>.<span class="pl-en">ok</span>(<span class="pl-c1">true</span>, <span class="pl-s"><span class="pl-pds">'</span>a timeout<span class="pl-pds">'</span></span>)
  })
  <span class="pl-c1">setTimeout</span>(<span class="pl-k">function</span> () {
    <span class="pl-smi">t</span>.<span class="pl-en">ok</span>(<span class="pl-c1">true</span>, <span class="pl-s"><span class="pl-pds">'</span>b timeout<span class="pl-pds">'</span></span>)
  })
})

<span class="pl-c">// you can do `var test = require('tap').test` if you like</span>
<span class="pl-c">// it's pre-bound to the root tap object.</span>

<span class="pl-k">var</span> test <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>tap<span class="pl-pds">'</span></span>).<span class="pl-smi">test</span>

<span class="pl-c">// subtests can have subtests</span>
<span class="pl-c1">test</span>(<span class="pl-k">function</span> <span class="pl-en">parent</span> (<span class="pl-smi">t</span>) {
  <span class="pl-smi">t</span>.<span class="pl-c1">test</span>(<span class="pl-k">function</span> <span class="pl-en">child</span> (<span class="pl-smi">tt</span>) {
    <span class="pl-smi">tt</span>.<span class="pl-en">throws</span>(<span class="pl-k">function</span> () {
      <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-en">Error</span>(<span class="pl-s"><span class="pl-pds">'</span>fooblz<span class="pl-pds">'</span></span>)
    }, {
      message<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>fooblz<span class="pl-pds">'</span></span>
    }, <span class="pl-s"><span class="pl-pds">'</span>throw a fooblz<span class="pl-pds">'</span></span>)

    <span class="pl-c">// throws also uses function name if no name provided</span>
    <span class="pl-smi">tt</span>.<span class="pl-en">throws</span>(<span class="pl-k">function</span> <span class="pl-en">throw_whatever</span> () { <span class="pl-k">throw</span> <span class="pl-c1">1</span> })

    <span class="pl-smi">tt</span>.<span class="pl-en">end</span>()
  })

  <span class="pl-smi">t</span>.<span class="pl-en">end</span>()
})

<span class="pl-c">// thrown errors just fail the current test, so you can</span>
<span class="pl-c">// also use your own assert library if you like.</span>
<span class="pl-c">// Of course, this means it won't be able to print out the</span>
<span class="pl-c">// number of passing asserts, since passes will be silent.</span>

<span class="pl-c1">test</span>(<span class="pl-s"><span class="pl-pds">'</span>my favorite assert lib<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">t</span>) {
  <span class="pl-k">var</span> assert <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>assert<span class="pl-pds">'</span></span>)
  <span class="pl-smi">assert</span>.<span class="pl-en">ok</span>(<span class="pl-c1">true</span>, <span class="pl-s"><span class="pl-pds">'</span>true is ok<span class="pl-pds">'</span></span>)
  <span class="pl-smi">assert</span>.<span class="pl-en">equal</span>(<span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">'</span>math works<span class="pl-pds">'</span></span>)

  <span class="pl-c">// Since it can't read the plan, using a custom assert lib</span>
  <span class="pl-c">// means that you MUST use t.end()</span>
  <span class="pl-smi">t</span>.<span class="pl-en">end</span>()
})

<span class="pl-c">// You can mark tests as 'todo' either using a conf object,</span>
<span class="pl-c">// or simply by omitting the callback.</span>
<span class="pl-c1">test</span>(<span class="pl-s"><span class="pl-pds">'</span>solve halting problem<span class="pl-pds">'</span></span>)
<span class="pl-c1">test</span>(<span class="pl-s"><span class="pl-pds">'</span>prove p=np<span class="pl-pds">'</span></span>, { todo<span class="pl-k">:</span> <span class="pl-c1">true</span> }, <span class="pl-k">function</span> (<span class="pl-smi">t</span>) {
  <span class="pl-c">// i guess stuff goes here</span>
  <span class="pl-smi">t</span>.<span class="pl-en">fail</span>(<span class="pl-s"><span class="pl-pds">'</span>traveling salesmen must pack their own bags<span class="pl-pds">'</span></span>)
  <span class="pl-smi">t</span>.<span class="pl-en">end</span>()
})

<span class="pl-c">// Prefer mocha/rspec/lab style global objects?</span>
<span class="pl-c">// Got you covered.  This is a little experimental,</span>
<span class="pl-c">// patches definitely welcome.</span>
<span class="pl-smi">tap</span>.<span class="pl-en">mochaGlobals</span>()
<span class="pl-en">describe</span>(<span class="pl-s"><span class="pl-pds">'</span>suite ride bro<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> () {
  <span class="pl-en">it</span>(<span class="pl-s"><span class="pl-pds">'</span>should have a wheel<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> () {
    <span class="pl-smi">assert</span>.<span class="pl-en">ok</span>(<span class="pl-smi">thingie</span>.<span class="pl-smi">wheel</span>, <span class="pl-s"><span class="pl-pds">'</span>wheel<span class="pl-pds">'</span></span>)
  })
  <span class="pl-en">it</span>(<span class="pl-s"><span class="pl-pds">'</span>can happen async<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">done</span>) {
    <span class="pl-c1">setTimeout</span>(<span class="pl-k">function</span> () {
      <span class="pl-smi">assert</span>.<span class="pl-en">ok</span>(<span class="pl-s"><span class="pl-pds">'</span>ok<span class="pl-pds">'</span></span>)
      <span class="pl-en">done</span>()
    })
  })
})

<span class="pl-c">// Read on for a complete list of asserts, methods, etc.</span></pre></div>

<p>You can run tests using the <code>tap</code> executable.  Put this in your
package.json file:</p>

<div class="highlight highlight-source-json"><pre>{
  <span class="pl-s"><span class="pl-pds">"</span>scripts<span class="pl-pds">"</span></span>: {
    <span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>tap test/*.js<span class="pl-pds">"</span></span>
  }
}</pre></div>

<p>and then you can run <code>npm test</code> to run your test scripts.</p>

<p>Command line behavior and flags:</p>

<pre><code>$ tap -h
Usage:
  tap [options] &lt;files&gt;

Executes all the files and interprets their output as TAP
formatted test result data.

To parse TAP data from stdin, specify "-" as a filename.

Short options are parsed gnu-style, so for example '-bCRspec' would be
equivalent to '--bail --no-color --reporter=spec'

Options:

  -c --color                  Use colors (Default for TTY)

  -C --no-color               Do not use colors (Default for non-TTY)

  -b --bail                   Bail out on first failure

  -B --no-bail                Do not bail out on first failure (Default)

  -R&lt;type&gt; --reporter=&lt;type&gt;  Use the specified reporter.  Defaults to
                              'classic' when colors are in use, or 'tap'
                              when colors are disabled.

                              Available reporters:
                              classic doc dot dump html htmlcov json
                              jsoncov jsonstream landing list markdown
                              min nyan progress silent spec tap xunit

  -s&lt;file&gt; --save=&lt;file&gt;      If &lt;file&gt; exists, then it should be a line-
                              delimited list of test files to run.  If
                              &lt;file&gt; is not present, then all command-line
                              positional arguments are run.

                              After the set of test files are run, any
                              failed test files are written back to the
                              save file.

                              This way, repeated runs with -s&lt;file&gt; will
                              re-run failures until all the failures are
                              passing, and then once again run all tests.

                              It's a good idea to .gitignore the file
                              used for this purpose, as it will churn a
                              lot.

  --coverage --cov            Capture coverage information using 'nyc'

                              If a COVERALLS_REPO_TOKEN environment
                              variable is set, then coverage is
                              captured by default and sent to the
                              coveralls.io service. If a CODECOV_TOKEN
                              environment variable is set, then coverage is
                              captured by default and sent to the
                              codecov.io service.

  --no-coverage --no-cov      Do not capture coverage information.
                              Note that if nyc is already loaded, then
                              the coverage info will still be captured.

  --coverage-report=&lt;type&gt;    Output coverage information using the
                              specified istanbul/nyc reporter type.

                              Default is 'text' when running on the
                              command line, or 'text-lcov' when piping
                              to coveralls or codecov.

                              If 'lcov' is used, then the report will
                              be opened in a web browser after running.

                              This can be run on its own at any time
                              after a test run that included coverage.

  -t&lt;n&gt; --timeout=&lt;n&gt;         Time out test files after &lt;n&gt; seconds.
                              Defaults to 30, or the value of the
                              TAP_TIMEOUT environment variable.

  -h --help                   print this thing you're looking at

  -v --version                show the version of this program

  -gc --expose-gc             Expose the gc() function to Node tests

  --debug                     Run JavaScript tests with node --debug

  --debug-brk                 Run JavaScript tests with node --debug-brk

  --harmony                   Enable all Harmony flags in JavaScript tests

  --strict                    Run JS tests in 'use strict' mode

  --                          Stop parsing flags, and treat any additional
                              command line arguments as filenames.
</code></pre>

<h2>
<a id="coverage" class="anchor" href="#coverage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Coverage</h2>

<p>This module uses <a href="http://npm.im/nyc">nyc</a> to track code coverage, even
across subprocess boundaries.  It is included by default, and there's
nothing you need to do but enable it.  Adding coverage <em>will</em> make
your tests run slightly slower, but that's to be expected.</p>

<p>To generate coverage information, run your tests with the <code>--cov</code>
argument.</p>

<p>To specify a report format, you can use <code>--coverage-report=&lt;type&gt;</code>.
The default type is <code>text</code>, which produces a pretty text-only table on
the terminal.  If you specify <code>--coverage-report=lcov</code>, then tap will
attempt to open a web browser to view the report after the test run.</p>

<p>If you use this a lot, you may want to add <code>coverage</code> and
<code>.nyc_output</code> to your <code>.gitignore</code> and/or <code>.npmignore</code> files.</p>

<h3>
<a id="travis-ci-and-coverallsiocodecovio-integration" class="anchor" href="#travis-ci-and-coverallsiocodecovio-integration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Travis-CI and Coveralls.io/CodeCov.io Integration</h3>

<p>You can very easily take advantage of continuous test coverage reports
by using <a href="https://travis-ci.org">Travis-CI</a> and
<a href="https://coveralls.io">Coveralls</a>.</p>

<ol>
<li>Enable Travis-CI by signing up, enabling tests on your repo, and
adding a <code>.travis.yml</code> file to your repo.  You can use <a href="https://github.com/isaacs/node-tap/blob/master/.travis.yml">this
module's .travis.yml file as an
example</a>
</li>
<li>Enable Coveralls.io or CodeCov.io by signing up, and adding the
repo.  Note the repo API token.</li>
<li>Back at Travis-CI, add a private environment variable.  The name of
the environment variable is <code>COVERALLS_REPO_TOKEN</code> for Coveralls,
or <code>CODECOV_TOKEN</code> for CodeCov.io, and the value is the token you
got from Coveralls or CodeCov.</li>
<li>When that token is set in the environment variable, <code>tap</code> will
automatically generate coverage information and send it to the
appropriate place.</li>
</ol>

<h2>
<a id="api" class="anchor" href="#api" aria-hidden="true"><span class="octicon octicon-link"></span></a>API</h2>

<h3>
<a id="tap--requiretap" class="anchor" href="#tap--requiretap" aria-hidden="true"><span class="octicon octicon-link"></span></a>tap = require('tap')</h3>

<p>The root <code>tap</code> object is an instance of the Test class with a few
slight modifications.</p>

<ol>
<li>The <code>tearDown()</code>, <code>plan()</code>, and <code>test()</code> methods are pre-bound onto
the root object, so that you don't have to call them as methods.</li>
<li>By default, it pipes to stdout, so running a test directly just
dumps the TAP data for inspection.  (You can of course
<code>tap.unpipe(process.stdout)</code> if you want to direct it elsewhere.)</li>
<li>Various other things are hung onto it for convenience, since it is
the main package export.</li>
<li>The test ends automatically when <code>process.on('exit')</code> fires, so
there is no need to call <code>tap.end()</code> explicitly.</li>
<li>Adding a <code>tearDown</code> function triggers <code>autoend</code> behavior.
Otherwise, the <code>end</code> would potentially never arrive, if for example
<code>tearDown</code> is used to close a server or cancel some long-running
process, because <code>process.on('exit')</code> would never fire of its own
accord.</li>
</ol>

<h3>
<a id="tapsynonyms" class="anchor" href="#tapsynonyms" aria-hidden="true"><span class="octicon octicon-link"></span></a>tap.synonyms</h3>

<p>A list of all of the canonical assert methods and their synonyms.</p>

<h3>
<a id="tapmochaglobals" class="anchor" href="#tapmochaglobals" aria-hidden="true"><span class="octicon octicon-link"></span></a>tap.mochaGlobals()</h3>

<p>Method that injects <code>describe()</code> and <code>it()</code> into the global
environment for mocha-like BDD style test definition.</p>

<p>This feature is incomplete, experimental, and may change drastically
in the future.  Feedback is welcome.</p>

<h3>
<a id="taptest" class="anchor" href="#taptest" aria-hidden="true"><span class="octicon octicon-link"></span></a>tap.Test</h3>

<p>The <code>Test</code> class is the main thing you'll be touching when you use
this module.</p>

<p>The most common way to instantiate a <code>Test</code> object by calling the
<code>test</code> method on the root or any other <code>Test</code> object.  The callback
passed to <code>test(name, fn)</code> will receive a child <code>Test</code> object as its
argument.</p>

<p>A <code>Test</code> object is a Readable Stream.  Child tests automatically send
their data to their parent, and the root <code>require('tap')</code> object pipes
to stdout by default.  However, you can instantiate a <code>Test</code> object
and then pipe it wherever you like.  The only limit is your imagination.</p>

<h4>
<a id="ttestname-options-function" class="anchor" href="#ttestname-options-function" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.test([name], [options], [function])</h4>

<p>Create a subtest.</p>

<p>If the function is omitted, then it will be marked as a "todo" or
"pending" test.</p>

<p>If the function has a name, and no name is provided, then the function
name will be used as the test name.  If no test name is provided, then
the name will be <code>(unnamed test)</code>.</p>

<p>The function gets a Test object as its only argument.  From there, you
can call the <code>t.end()</code> method on that object to end the test, or use
the <code>t.plan()</code> method to specify how many child tests or asserts the
test will have.</p>

<p>If the function returns a <code>Promise</code> object (that is, an object with a
<code>then</code> method), then when the promise is rejected or fulfilled, the
test will be either ended or failed.</p>

<p>If the function is not provided, then this will be treated as a <code>todo</code>
test.</p>

<p>The options object is the same as would be passed to any assert, with
two additional fields that are only relevant for child tests:</p>

<ul>
<li>
<code>timeout</code>: The number of ms to allow the test to run.</li>
<li>
<code>bail</code>: Set to <code>true</code> to bail out on the first test failure.</li>
<li>
<code>autoend</code>: Automatically <code>end()</code> the test on the next turn of the
event loop after its internal queue is drained.</li>
</ul>

<h4>
<a id="tteardownfunction" class="anchor" href="#tteardownfunction" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.tearDown(function)</h4>

<p>Run the supplied function when <code>t.end()</code> is called, or when the <code>plan</code>
is met.</p>

<p>Note that when called on the root <code>tap</code> export, this also triggers
<code>autoend</code> behavior.</p>

<h4>
<a id="tautoend" class="anchor" href="#tautoend" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.autoend()</h4>

<p>Automatically end the test as soon as there is nothing pending in its
queue.</p>

<p>The automatic end is deferred with a <code>setTimeout</code>, and any new action
will cancel and re-schedule the timer.  Nonetheless, calling this
method means that any slow asynchronous behavior may be lost, if it
comes after the <code>end()</code> is auto-triggered.</p>

<p>This behavior is triggered on the root <code>tap</code> object when
<code>tap.tearDown()</code> is called.</p>

<h4>
<a id="tplannumber" class="anchor" href="#tplannumber" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.plan(number)</h4>

<p>Specify that a given number of tests are going to be run.</p>

<p>This may only be called <em>before</em> running any asserts or child tests.</p>

<h4>
<a id="tend" class="anchor" href="#tend" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.end()</h4>

<p>Call when tests are done running.  This is not necessary if <code>t.plan()</code>
was used, or if the test function returns a Promise.</p>

<p>If you call <code>t.end()</code> explicitly more than once, an error will be
raised.</p>

<h4>
<a id="tbailoutreason" class="anchor" href="#tbailoutreason" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.bailout([reason])</h4>

<p>Pull the proverbial ejector seat.</p>

<p>Use this when things are severely broken, and cannot be reasonably
handled.  Immediately terminates the entire test run.</p>

<h4>
<a id="tpassing" class="anchor" href="#tpassing" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.passing()</h4>

<p>Return true if everything so far is ok.</p>

<p>Note that all assert methods also return <code>true</code> if they pass.</p>

<h4>
<a id="tcommentmessage" class="anchor" href="#tcommentmessage" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.comment(message)</h4>

<p>Print the supplied message as a TAP comment.</p>

<p>Note that you can always use <code>console.error()</code> for debugging (or
<code>console.log()</code> as long as the message doesn't look like TAP formatted
data).</p>

<h4>
<a id="tfailmessage-extra" class="anchor" href="#tfailmessage-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.fail(message, extra)</h4>

<p>Emit a failing test point.  This method, and <code>pass()</code>, are the basic
building blocks of all fancier assertions.</p>

<h4>
<a id="tpassmessage" class="anchor" href="#tpassmessage" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.pass(message)</h4>

<p>Emit a passing test point.  This method, and <code>fail()</code>, are the basic
building blocks of all fancier assertions.</p>

<h4>
<a id="tpragmaset" class="anchor" href="#tpragmaset" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.pragma(set)</h4>

<p>Sets a <code>pragma</code> switch for a set of boolean keys in the argument.</p>

<p>The only pragma currently supported by the TAP parser is <code>strict</code>,
which tells the parser to treat non-TAP output as a failure.</p>

<p>Example:</p>

<pre><code>var t = require('tap')
console.log('this non-TAP output is ok')
t.pragma({ strict: true })
console.log('but this will cause a failure')
</code></pre>

<h3>
<a id="asserts" class="anchor" href="#asserts" aria-hidden="true"><span class="octicon octicon-link"></span></a>Asserts</h3>

<p>The <code>Test</code> object has a collection of assertion methods, many of which
are given several synonyms for compatibility with other test runners
and the vagaries of human expectations and spelling.  When a synonym
is multi-word in <code>camelCase</code> the corresponding lower case and
<code>snake_case</code> versions are also created as synonyms.</p>

<p>All assertion methods take optional <code>message</code> and <code>extra</code> arguments as
the last two params.  The <code>message</code> is the name of the test.  The
<code>extra</code> argument can contain any arbitrary data about the test, but
the following fields are "special".</p>

<ul>
<li>
<code>todo</code> Set to boolean <code>true</code> or a String to mark this as pending</li>
<li>
<code>skip</code> Set to boolean <code>true</code> or a String to mark this as skipped</li>
<li>
<code>at</code> Generated by the framework.  The location where the assertion
was called.  Do not set this field.</li>
<li>
<code>stack</code> Generated by the framework.  The stack trace to the point
where the assertion was called.  Do not set this field.</li>
</ul>

<h4>
<a id="tokobj-message-extra" class="anchor" href="#tokobj-message-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.ok(obj, message, extra)</h4>

<p>Verifies that the object is truthy.</p>

<p>Synonyms: <code>t.true</code>, <code>t.assert</code></p>

<h4>
<a id="tnotokobj-message-extra" class="anchor" href="#tnotokobj-message-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.notOk(obj, message, extra)</h4>

<p>Verifies that the object is not truthy.</p>

<p>Synonyms: <code>t.false</code>, <code>t.assertNot</code></p>

<h4>
<a id="terrorobj-message-extra" class="anchor" href="#terrorobj-message-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.error(obj, message, extra)</h4>

<p>If the object is an error, then the assertion fails.</p>

<p>Note: if an error is encountered unexpectedly, it's often better to
simply throw it.  The Test object will handle this as a failure.</p>

<p>Synonyms: <code>t.ifErr</code>, <code>t.ifError</code></p>

<h4>
<a id="tthrowsfn-expectederror-message-extra" class="anchor" href="#tthrowsfn-expectederror-message-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.throws(fn, [expectedError], message, extra)</h4>

<p>Expect the function to throw an error.  If an expected error is
provided, then also verify that the thrown error matches the expected
error.</p>

<p>If the function has a name, and the message is not provided, then the
function name will be used as the message.</p>

<p>If the function is not provided, then this will be treated as a <code>todo</code>
test.</p>

<p>Caveat: if you pass a <code>extra</code> object to t.throws, then you MUST also
pass in an expected error, or else it will read the diag object as the
expected error, and get upset when your thrown error doesn't match
<code>{skip:true}</code> or whatever.</p>

<p>For example, this will not work as expected:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">t</span>.<span class="pl-en">throws</span>(<span class="pl-k">function</span>() {<span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-en">Error</span>(<span class="pl-s"><span class="pl-pds">'</span>x<span class="pl-pds">'</span></span>)}, { skip<span class="pl-k">:</span> <span class="pl-c1">true</span> })</pre></div>

<p>But this is fine:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// note the empty 'expected error' object.</span>
<span class="pl-c">// since it has no fields, it'll only verify that the thrown thing is</span>
<span class="pl-c">// an object, not the value of any properties</span>
<span class="pl-smi">t</span>.<span class="pl-en">throws</span>(<span class="pl-k">function</span>() {<span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-en">Error</span>(<span class="pl-s"><span class="pl-pds">'</span>x<span class="pl-pds">'</span></span>)}, {}, { skip<span class="pl-k">:</span> <span class="pl-c1">true</span> })</pre></div>

<p>The expected error is tested against the throw error using <code>t.match</code>,
so regular expressions and the like are fine.  If the expected error
is an <code>Error</code> object, then the <code>stack</code> field is ignored, since that
will generally never match.</p>

<p>Synonyms: <code>t.throw</code></p>

<h4>
<a id="tdoesnotthrowfn-message-extra" class="anchor" href="#tdoesnotthrowfn-message-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.doesNotThrow(fn, message, extra)</h4>

<p>Verify that the provided function does not throw.</p>

<p>If the function has a name, and the message is not provided, then the
function name will be used as the message.</p>

<p>If the function is not provided, then this will be treated as a <code>todo</code>
test.</p>

<p>Note: if an error is encountered unexpectedly, it's often better to
simply throw it.  The Test object will handle this as a failure.</p>

<p>Synonyms: <code>t.notThrow</code></p>

<h4>
<a id="tequalfound-wanted-message-extra" class="anchor" href="#tequalfound-wanted-message-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.equal(found, wanted, message, extra)</h4>

<p>Verify that the object found is exactly the same (that is, <code>===</code>) to
the object that is wanted.</p>

<p>Synonyms: <code>t.equals</code>, <code>t.isEqual</code>, <code>t.is</code>, <code>t.strictEqual</code>,
<code>t.strictEquals</code>, <code>t.strictIs</code>, <code>t.isStrict</code>, <code>t.isStrictly</code></p>

<h4>
<a id="tnotequalfound-notwanted-message-extra" class="anchor" href="#tnotequalfound-notwanted-message-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.notEqual(found, notWanted, message, extra)</h4>

<p>Inverse of <code>t.equal()</code>.</p>

<p>Verify that the object found is not exactly the same (that is, <code>!==</code>) as
the object that is wanted.</p>

<p>Synonyms: <code>t.inequal</code>, <code>t.notEqual</code>, <code>t.notEquals</code>,
<code>t.notStrictEqual</code>, <code>t.notStrictEquals</code>, <code>t.isNotEqual</code>, <code>t.isNot</code>,
<code>t.doesNotEqual</code>, <code>t.isInequal</code></p>

<h4>
<a id="tsamefound-wanted-message-extra" class="anchor" href="#tsamefound-wanted-message-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.same(found, wanted, message, extra)</h4>

<p>Verify that the found object is deeply equivalent to the wanted
object.  Use non-strict equality for scalars (ie, <code>==</code>).</p>

<p>Synonyms: <code>t.equivalent</code>, <code>t.looseEqual</code>, <code>t.looseEquals</code>,
<code>t.deepEqual</code>, <code>t.deepEquals</code>, <code>t.isLoose</code>, <code>t.looseIs</code></p>

<h4>
<a id="tnotsamefound-notwanted-message-extra" class="anchor" href="#tnotsamefound-notwanted-message-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.notSame(found, notWanted, message, extra)</h4>

<p>Inverse of <code>t.same()</code>.</p>

<p>Verify that the found object is not deeply equivalent to the
unwanted object.  Uses non-strict inequality (ie, <code>!=</code>) for scalars.</p>

<p>Synonyms: <code>t.inequivalent</code>, <code>t.looseInequal</code>, <code>t.notDeep</code>,
<code>t.deepInequal</code>, <code>t.notLoose</code>, <code>t.looseNot</code></p>

<h4>
<a id="tstrictsamefound-wanted-message-extra" class="anchor" href="#tstrictsamefound-wanted-message-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.strictSame(found, wanted, message, extra)</h4>

<p>Strict version of <code>t.same()</code>.</p>

<p>Verify that the found object is deeply equivalent to the wanted
object.  Use strict equality for scalars (ie, <code>===</code>).</p>

<p>Synonyms: <code>t.strictEquivalent</code>, <code>t.strictDeepEqual</code>, <code>t.sameStrict</code>,
<code>t.deepIs</code>, <code>t.isDeeply</code>, <code>t.isDeep</code>, <code>t.strictDeepEquals</code></p>

<h4>
<a id="tstrictnotsamefound-notwanted-message-extra" class="anchor" href="#tstrictnotsamefound-notwanted-message-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.strictNotSame(found, notWanted, message, extra)</h4>

<p>Inverse of <code>t.strictSame()</code>.</p>

<p>Verify that the found object is not deeply equivalent to the unwanted
object.  Use strict equality for scalars (ie, <code>===</code>).</p>

<p>Synonyms: <code>t.strictInequivalent</code>, <code>t.strictDeepInequal</code>,
<code>t.notSameStrict</code>, <code>t.deepNot</code>, <code>t.notDeeply</code>, <code>t.strictDeepInequals</code>,
<code>t.notStrictSame</code></p>

<h4>
<a id="tmatchfound-pattern-message-extra" class="anchor" href="#tmatchfound-pattern-message-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.match(found, pattern, message, extra)</h4>

<p>Verify that the found object matches the pattern provided.</p>

<p>If pattern is a regular expression, and found is a string, then verify
that the string matches the pattern.</p>

<p>If the pattern is a string, and found is a string, then verify that
the pattern occurs within the string somewhere.</p>

<p>If pattern is an object, then verify that all of the (enumerable)
fields in the pattern match the corresponding fields in the object
using this same algorithm.  For example, the pattern <code>{x:/a[sdf]{3}/}</code>
would successfully match <code>{x:'asdf',y:'z'}</code>.</p>

<p>This is useful when you want to verify that an object has a certain
set of required fields, but additional fields are ok.</p>

<p>Synonyms: <code>t.has</code>, <code>t.hasFields</code>, <code>t.matches</code>, <code>t.similar</code>, <code>t.like</code>,
<code>t.isLike</code>, <code>t.includes</code>, <code>t.include</code>, <code>t.contains</code></p>

<h4>
<a id="tnotmatchfound-pattern-message-extra" class="anchor" href="#tnotmatchfound-pattern-message-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.notMatch(found, pattern, message, extra)</h4>

<p>Interse of <code>match()</code></p>

<p>Verify that the found object does not match the pattern provided.</p>

<p>Synonyms: <code>t.dissimilar</code>, <code>t.unsimilar</code>, <code>t.notSimilar</code>, <code>t.unlike</code>,
<code>t.isUnlike</code>, <code>t.notLike</code>, <code>t.isNotLike</code>, <code>t.doesNotHave</code>,
<code>t.isNotSimilar</code>, <code>t.isDissimilar</code></p>

<h4>
<a id="ttypeobject-type-message-extra" class="anchor" href="#ttypeobject-type-message-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.type(object, type, message, extra)</h4>

<p>Verify that the object is of the type provided.</p>

<p>Type can be a string that matches the <code>typeof</code> value of the object, or
the string name of any constructor in the object's prototype chain, or
a constructor function in the object's prototype chain.</p>

<p>For example, all the following will pass:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">t</span>.<span class="pl-c1">type</span>(<span class="pl-k">new</span> <span class="pl-en">Date</span>(), <span class="pl-s"><span class="pl-pds">'</span>object<span class="pl-pds">'</span></span>)
<span class="pl-smi">t</span>.<span class="pl-c1">type</span>(<span class="pl-k">new</span> <span class="pl-en">Date</span>(), <span class="pl-s"><span class="pl-pds">'</span>Date<span class="pl-pds">'</span></span>)
<span class="pl-smi">t</span>.<span class="pl-c1">type</span>(<span class="pl-k">new</span> <span class="pl-en">Date</span>(), <span class="pl-c1">Date</span>)</pre></div>

<p>Synonyms: <code>t.isa</code>, <code>t.isA</code></p>

<h3>
<a id="advanced-usage" class="anchor" href="#advanced-usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Advanced Usage</h3>

<p>These methods are primarily for internal use, but can be handy in some
unusual situations.  If you find yourself using them frequently, you
<em>may</em> be Doing It Wrong.  However, if you find them useful, you should
feel perfectly comfortable using them.</p>

<p>Please <a href="https://github.com/isaacs/node-tap/issues">let us know</a> if you
frequently encounter situations requiring advanced usage, because this
may indicate a shortcoming in the "non-advanced" API.</p>

<h4>
<a id="tstdin" class="anchor" href="#tstdin" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.stdin()</h4>

<p>Parse standard input as if it was a child test named <code>/dev/stdin</code>.</p>

<p>This is primarily for use in the test runner, so that you can do
<code>some-tap-emitting-program | tap other-file.js - -Rnyan</code>.</p>

<h4>
<a id="tspawncommand-arguments-options-name-extra" class="anchor" href="#tspawncommand-arguments-options-name-extra" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.spawn(command, arguments, [options], [name], [extra])</h4>

<p>Sometimes, instead of running a child test directly inline, you might
want to run a TAP producting test as a child process, and treat its
standard output as the TAP stream.</p>

<p>That's what this method does.</p>

<p>It is primarily used by the executable runner, to run all of the
filename arguments provided on the command line.</p>

<p>The <code>options</code> object is passed to <code>child_process.spawn</code>, and can
contain stuff like stdio directives and environment vars.</p>

<p>The <code>extra</code> arg is the same that would be passed to any assertion or
child test, with the addition of the following fields:</p>

<ul>
<li>
<code>bail</code>: Set to <code>true</code> to bail out on the first failure.  This is
done by checking the output and then forcibly killing the process,
but also sets the <code>TAP_BAIL</code> environment variable, which node-tap
uses to set this field internally as well.</li>
<li>
<code>timeout</code>: The number of ms to allow the child process to continue.
If it goes beyond this time, the child process will be forcibly
killed.</li>
</ul>

<h4>
<a id="taddassertname-length-fn" class="anchor" href="#taddassertname-length-fn" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.addAssert(name, length, fn)</h4>

<p>This is used for creating assertion methods on the <code>Test</code> class.</p>

<p>It's a little bit advanced, but it's also super handy sometimes.  All
of the assert methods below are created using this function, and it
can be used to create application-specific assertions in your tests.</p>

<p>The name is the method name that will be created.  The length is the
number of arguments the assertion operates on.  (The <code>message</code> and
<code>extra</code> arguments will alwasy be appended to the end.)</p>

<p>For example, you could have a file at <code>test/setup.js</code> that does the
following:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> tap <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>tap<span class="pl-pds">'</span></span>)

<span class="pl-c">// convenience</span>
<span class="pl-k">if</span> (<span class="pl-c1">module</span> <span class="pl-k">===</span> <span class="pl-smi">require</span>.<span class="pl-smi">main</span>) {
  <span class="pl-smi">tap</span>.<span class="pl-en">pass</span>(<span class="pl-s"><span class="pl-pds">'</span>ok<span class="pl-pds">'</span></span>)
  <span class="pl-k">return</span>
}

<span class="pl-c">// Add an assertion that a string is in Title Case</span>
<span class="pl-c">// It takes one argument (the string to be tested)</span>
<span class="pl-smi">tap</span>.<span class="pl-smi">Test</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">addAssert</span>(<span class="pl-s"><span class="pl-pds">'</span>titleCase<span class="pl-pds">'</span></span>, <span class="pl-c1">1</span>, <span class="pl-k">function</span> (<span class="pl-smi">str</span>, <span class="pl-smi">message</span>, <span class="pl-smi">extra</span>) {
  message <span class="pl-k">=</span> message <span class="pl-k">||</span> <span class="pl-s"><span class="pl-pds">'</span>should be in Title Case<span class="pl-pds">'</span></span>
  <span class="pl-c">// the string in Title Case</span>
  <span class="pl-c">// A fancier implementation would avoid capitalizing little words</span>
  <span class="pl-c">// to get `Silence of the Lambs` instead of `Silence Of The Lambs`</span>
  <span class="pl-c">// But whatever, it's just an example.</span>
  <span class="pl-k">var</span> tc <span class="pl-k">=</span> <span class="pl-smi">str</span>.<span class="pl-c1">toLowerCase</span>().<span class="pl-c1">replace</span>(<span class="pl-sr"><span class="pl-pds">/</span><span class="pl-k">\b</span><span class="pl-c1">.</span><span class="pl-pds">/</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">match</span>) {
    <span class="pl-k">return</span> <span class="pl-smi">match</span>.<span class="pl-c1">toUpperCase</span>()
  })

  <span class="pl-c">// should always return another assert call, or</span>
  <span class="pl-c">// this.pass(message) or this.fail(message, extra)</span>
  <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-en">equal</span>(str, tc, message, extra)
})</pre></div>

<p>Then in your individual tests, you'd do this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./setup.js<span class="pl-pds">'</span></span>) <span class="pl-c">// adds the assert</span>
<span class="pl-k">var</span> tap <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>tap<span class="pl-pds">'</span></span>)
<span class="pl-smi">tap</span>.<span class="pl-en">titleCase</span>(<span class="pl-s"><span class="pl-pds">'</span>This Passes<span class="pl-pds">'</span></span>)
<span class="pl-smi">tap</span>.<span class="pl-en">titleCase</span>(<span class="pl-s"><span class="pl-pds">'</span>however, tHis tOTaLLy faILS<span class="pl-pds">'</span></span>)</pre></div>

<h4>
<a id="tendall" class="anchor" href="#tendall" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.endAll()</h4>

<p>Call the <code>end()</code> method on all child tests, and then on this one.</p>

<h4>
<a id="tcurrent" class="anchor" href="#tcurrent" aria-hidden="true"><span class="octicon octicon-link"></span></a>t.current()</h4>

<p>Return the currently active test.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/tapjs">tapjs</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
